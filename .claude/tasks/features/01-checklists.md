# Checklist System — Implementation Plan

## 1. Overview

Add multi-checklist support to tasks. Each task can have multiple named checklists (e.g. "QA Steps", "Deploy Checklist"), each containing ordered, toggleable items with optional assignee and due date.

### User Stories

- As a user, I can add one or more named checklists to a task
- As a user, I can add items to a checklist and reorder them via drag-and-drop
- As a user, I can check/uncheck items; the progress updates in real time
- As a user, I can see aggregate checklist progress on the board TaskCard
- As a user, I can assign a checklist item to a project member
- As a user, I can set a due date on individual checklist items
- As a user, I can reorder checklists within a task
- As a user, I can delete a checklist (cascade deletes its items)
- As a user, I see real-time checklist updates from other collaborators via WebSocket

---

## 2. Data Model

### `Checklist` (table: `checklists`)

```python
# backend/app/models/checklist.py

import uuid
from datetime import UTC, datetime

from sqlalchemy import DateTime, Float, ForeignKey, Index, String
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.core.database import Base


class Checklist(Base):
    __tablename__ = "checklists"
    __table_args__ = (
        Index("ix_checklists_task_position", "task_id", "position"),
    )

    id: Mapped[uuid.UUID] = mapped_column(primary_key=True, default=uuid.uuid4)
    task_id: Mapped[uuid.UUID] = mapped_column(
        ForeignKey("tasks.id", ondelete="CASCADE")
    )
    title: Mapped[str] = mapped_column(String(300))
    position: Mapped[float] = mapped_column(Float, default=0.0)

    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), default=lambda: datetime.now(UTC)
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        default=lambda: datetime.now(UTC),
        onupdate=lambda: datetime.now(UTC),
    )

    task = relationship("Task", back_populates="checklists")
    items = relationship(
        "ChecklistItem",
        back_populates="checklist",
        cascade="all, delete-orphan",
        order_by="ChecklistItem.position",
    )
```

### `ChecklistItem` (table: `checklist_items`)

```python
# backend/app/models/checklist_item.py

import uuid
from datetime import UTC, datetime

from sqlalchemy import Boolean, DateTime, Float, ForeignKey, Index, String
from sqlalchemy.orm import Mapped, mapped_column, relationship

from app.core.database import Base


class ChecklistItem(Base):
    __tablename__ = "checklist_items"
    __table_args__ = (
        Index("ix_checklist_items_checklist_position", "checklist_id", "position"),
    )

    id: Mapped[uuid.UUID] = mapped_column(primary_key=True, default=uuid.uuid4)
    checklist_id: Mapped[uuid.UUID] = mapped_column(
        ForeignKey("checklists.id", ondelete="CASCADE")
    )
    title: Mapped[str] = mapped_column(String(500))
    is_completed: Mapped[bool] = mapped_column(Boolean, default=False)
    position: Mapped[float] = mapped_column(Float, default=0.0)
    assignee_id: Mapped[uuid.UUID | None] = mapped_column(
        ForeignKey("users.id", ondelete="SET NULL"), nullable=True
    )
    due_date: Mapped[datetime | None] = mapped_column(DateTime(timezone=True))
    completed_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=True))

    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), default=lambda: datetime.now(UTC)
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        default=lambda: datetime.now(UTC),
        onupdate=lambda: datetime.now(UTC),
    )

    checklist = relationship("Checklist", back_populates="items")
    assignee = relationship("User", foreign_keys=[assignee_id])
```

### Task Model Update

Add `checklists` relationship to `Task`:

```python
# In backend/app/models/task.py, add to Task class:
checklists = relationship(
    "Checklist", back_populates="task", cascade="all, delete-orphan",
    order_by="Checklist.position",
)
```

---

## 3. Database Migration

**File:** `backend/alembic/versions/<autogenerated>_add_checklists.py`

```python
"""add_checklists

Revision ID: <auto>
Revises: a1b2c3d4e5f6
"""
from alembic import op
import sqlalchemy as sa

def upgrade() -> None:
    op.create_table(
        'checklists',
        sa.Column('id', sa.Uuid(), nullable=False),
        sa.Column('task_id', sa.Uuid(), nullable=False),
        sa.Column('title', sa.String(300), nullable=False),
        sa.Column('position', sa.Float(), nullable=False, server_default='0'),
        sa.Column('created_at', sa.DateTime(timezone=True), nullable=False),
        sa.Column('updated_at', sa.DateTime(timezone=True), nullable=False),
        sa.ForeignKeyConstraint(['task_id'], ['tasks.id'], ondelete='CASCADE'),
        sa.PrimaryKeyConstraint('id'),
    )
    op.create_index('ix_checklists_task_position', 'checklists', ['task_id', 'position'])

    op.create_table(
        'checklist_items',
        sa.Column('id', sa.Uuid(), nullable=False),
        sa.Column('checklist_id', sa.Uuid(), nullable=False),
        sa.Column('title', sa.String(500), nullable=False),
        sa.Column('is_completed', sa.Boolean(), nullable=False, server_default='0'),
        sa.Column('position', sa.Float(), nullable=False, server_default='0'),
        sa.Column('assignee_id', sa.Uuid(), nullable=True),
        sa.Column('due_date', sa.DateTime(timezone=True), nullable=True),
        sa.Column('completed_at', sa.DateTime(timezone=True), nullable=True),
        sa.Column('created_at', sa.DateTime(timezone=True), nullable=False),
        sa.Column('updated_at', sa.DateTime(timezone=True), nullable=False),
        sa.ForeignKeyConstraint(['checklist_id'], ['checklists.id'], ondelete='CASCADE'),
        sa.ForeignKeyConstraint(['assignee_id'], ['users.id'], ondelete='SET NULL'),
        sa.PrimaryKeyConstraint('id'),
    )
    op.create_index('ix_checklist_items_checklist_position', 'checklist_items', ['checklist_id', 'position'])

def downgrade() -> None:
    op.drop_table('checklist_items')
    op.drop_table('checklists')
```

### Model Registration

**File:** `backend/app/models/__init__.py` — add:
```python
from app.models.checklist import Checklist
from app.models.checklist_item import ChecklistItem
```

Add `"Checklist"` and `"ChecklistItem"` to `__all__`.

---

## 4. Backend API

### Pydantic Schemas

**File:** `backend/app/schemas/checklist.py`

```python
from datetime import datetime
from uuid import UUID

from pydantic import BaseModel, ConfigDict, Field

from .user import UserBrief


# ── Checklist Item ──

class ChecklistItemCreate(BaseModel):
    title: str = Field(min_length=1, max_length=500)
    assignee_id: UUID | None = None
    due_date: datetime | None = None

class ChecklistItemUpdate(BaseModel):
    title: str | None = None
    is_completed: bool | None = None
    assignee_id: UUID | None = None
    due_date: datetime | None = None

class ChecklistItemReorder(BaseModel):
    position: float

class ChecklistItemResponse(BaseModel):
    model_config = ConfigDict(from_attributes=True)

    id: UUID
    checklist_id: UUID
    title: str
    is_completed: bool
    position: float
    assignee: UserBrief | None = None
    due_date: datetime | None = None
    completed_at: datetime | None = None
    created_at: datetime
    updated_at: datetime | None = None


# ── Checklist ──

class ChecklistCreate(BaseModel):
    title: str = Field(min_length=1, max_length=300)

class ChecklistUpdate(BaseModel):
    title: str | None = None

class ChecklistReorder(BaseModel):
    position: float

class ChecklistResponse(BaseModel):
    model_config = ConfigDict(from_attributes=True)

    id: UUID
    task_id: UUID
    title: str
    position: float
    items: list[ChecklistItemResponse] = []
    created_at: datetime
    updated_at: datetime | None = None


# ── Aggregate progress (embedded in TaskResponse) ──

class ChecklistProgress(BaseModel):
    total: int = 0
    completed: int = 0
```

### Schema Registration

**File:** `backend/app/schemas/__init__.py` — add imports and exports:
```python
from .checklist import (
    ChecklistCreate,
    ChecklistItemCreate,
    ChecklistItemReorder,
    ChecklistItemResponse,
    ChecklistItemUpdate,
    ChecklistProgress,
    ChecklistReorder,
    ChecklistResponse,
    ChecklistUpdate,
)
```

### TaskResponse Update

**File:** `backend/app/schemas/task.py` — add to `TaskResponse`:
```python
checklist_progress: ChecklistProgress = ChecklistProgress()
```

Add a `model_validator(mode="before")` named `resolve_checklist_progress` that computes the aggregate from the task's checklists relationship:

```python
@model_validator(mode="before")
@classmethod
def resolve_checklist_progress(cls, data):
    if hasattr(data, "checklists"):
        total = 0
        completed = 0
        for cl in data.checklists:
            for item in cl.items:
                total += 1
                if item.is_completed:
                    completed += 1
        data.__dict__["checklist_progress"] = {"total": total, "completed": completed}
    return data
```

### Endpoint List

All under prefix: `/projects/{project_id}/boards/{board_id}/tasks/{task_id}/checklists`

| Method | Path | Handler | Description |
|--------|------|---------|-------------|
| `GET` | `/` | `list_checklists` | List all checklists for a task (with items) |
| `POST` | `/` | `create_checklist` | Create a new checklist |
| `PATCH` | `/{checklist_id}` | `update_checklist` | Update checklist title |
| `DELETE` | `/{checklist_id}` | `delete_checklist` | Delete checklist + items |
| `PATCH` | `/{checklist_id}/reorder` | `reorder_checklist` | Update checklist position |
| `POST` | `/{checklist_id}/items` | `create_item` | Add item to checklist |
| `PATCH` | `/{checklist_id}/items/{item_id}` | `update_item` | Update item fields (title, assignee, due_date) |
| `DELETE` | `/{checklist_id}/items/{item_id}` | `delete_item` | Delete item |
| `POST` | `/{checklist_id}/items/{item_id}/toggle` | `toggle_item` | Toggle is_completed |
| `PATCH` | `/{checklist_id}/items/{item_id}/reorder` | `reorder_item` | Update item position |

**Auth:** All endpoints require board access (`check_board_access` dependency) + `get_current_user`.

### Route File

**File:** `backend/app/api/v1/checklists.py`

```python
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession

from app.api.deps import check_board_access, get_current_user
from app.core.database import get_db
from app.crud import crud_task
from app.crud.checklist import crud_checklist
from app.crud.checklist_item import crud_checklist_item
from app.models.board import Board
from app.models.user import User
from app.schemas.base import ResponseBase
from app.schemas.checklist import (
    ChecklistCreate,
    ChecklistItemCreate,
    ChecklistItemReorder,
    ChecklistItemResponse,
    ChecklistItemUpdate,
    ChecklistReorder,
    ChecklistResponse,
    ChecklistUpdate,
)
from app.services.checklist_service import ChecklistService
from app.services.websocket_manager import manager

router = APIRouter(
    prefix="/projects/{project_id}/boards/{board_id}/tasks/{task_id}/checklists",
    tags=["Checklists"],
)


async def _get_task_or_404(task_id: UUID, board: Board, db: AsyncSession):
    task = await crud_task.get(db, task_id)
    if not task or task.board_id != board.id:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Task not found")
    return task


async def _get_checklist_or_404(checklist_id: UUID, task_id: UUID, db: AsyncSession):
    checklist = await crud_checklist.get_with_items(db, checklist_id)
    if not checklist or checklist.task_id != task_id:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Checklist not found")
    return checklist


async def _broadcast_checklist_update(board: Board, task_id: UUID):
    """Notify board clients that checklists changed on a task."""
    await manager.broadcast_to_board(
        str(board.project_id),
        str(board.id),
        {
            "type": "checklist.updated",
            "project_id": str(board.project_id),
            "board_id": str(board.id),
            "data": {"task_id": str(task_id)},
        },
    )


# ── Checklist CRUD ──

@router.get("/", response_model=ResponseBase[list[ChecklistResponse]])
async def list_checklists(
    task_id: UUID,
    db: AsyncSession = Depends(get_db),
    board: Board = Depends(check_board_access),
):
    await _get_task_or_404(task_id, board, db)
    checklists = await crud_checklist.get_multi_by_task(db, task_id)
    return ResponseBase(data=[ChecklistResponse.model_validate(c) for c in checklists])


@router.post("/", response_model=ResponseBase[ChecklistResponse], status_code=201)
async def create_checklist(
    task_id: UUID,
    body: ChecklistCreate,
    db: AsyncSession = Depends(get_db),
    board: Board = Depends(check_board_access),
    current_user: User = Depends(get_current_user),
):
    task = await _get_task_or_404(task_id, board, db)
    checklist = await ChecklistService.create_checklist(db, task, current_user.id, body)
    await _broadcast_checklist_update(board, task_id)
    return ResponseBase(data=ChecklistResponse.model_validate(checklist))


@router.patch("/{checklist_id}", response_model=ResponseBase[ChecklistResponse])
async def update_checklist(
    task_id: UUID,
    checklist_id: UUID,
    body: ChecklistUpdate,
    db: AsyncSession = Depends(get_db),
    board: Board = Depends(check_board_access),
    current_user: User = Depends(get_current_user),
):
    checklist = await _get_checklist_or_404(checklist_id, task_id, db)
    updated = await ChecklistService.update_checklist(db, checklist, current_user.id, body)
    await _broadcast_checklist_update(board, task_id)
    return ResponseBase(data=ChecklistResponse.model_validate(updated))


@router.delete("/{checklist_id}", status_code=204)
async def delete_checklist(
    task_id: UUID,
    checklist_id: UUID,
    db: AsyncSession = Depends(get_db),
    board: Board = Depends(check_board_access),
    current_user: User = Depends(get_current_user),
):
    checklist = await _get_checklist_or_404(checklist_id, task_id, db)
    await ChecklistService.delete_checklist(db, checklist, current_user.id)
    await _broadcast_checklist_update(board, task_id)


@router.patch("/{checklist_id}/reorder", response_model=ResponseBase[ChecklistResponse])
async def reorder_checklist(
    task_id: UUID,
    checklist_id: UUID,
    body: ChecklistReorder,
    db: AsyncSession = Depends(get_db),
    board: Board = Depends(check_board_access),
):
    checklist = await _get_checklist_or_404(checklist_id, task_id, db)
    checklist.position = body.position
    db.add(checklist)
    await db.flush()
    await db.refresh(checklist)
    await _broadcast_checklist_update(board, task_id)
    return ResponseBase(data=ChecklistResponse.model_validate(checklist))


# ── Checklist Item CRUD ──

@router.post("/{checklist_id}/items", response_model=ResponseBase[ChecklistItemResponse], status_code=201)
async def create_item(
    task_id: UUID,
    checklist_id: UUID,
    body: ChecklistItemCreate,
    db: AsyncSession = Depends(get_db),
    board: Board = Depends(check_board_access),
    current_user: User = Depends(get_current_user),
):
    checklist = await _get_checklist_or_404(checklist_id, task_id, db)
    item = await ChecklistService.create_item(db, checklist, current_user.id, body)
    await _broadcast_checklist_update(board, task_id)
    return ResponseBase(data=ChecklistItemResponse.model_validate(item))


@router.patch("/{checklist_id}/items/{item_id}", response_model=ResponseBase[ChecklistItemResponse])
async def update_item(
    task_id: UUID,
    checklist_id: UUID,
    item_id: UUID,
    body: ChecklistItemUpdate,
    db: AsyncSession = Depends(get_db),
    board: Board = Depends(check_board_access),
    current_user: User = Depends(get_current_user),
):
    await _get_checklist_or_404(checklist_id, task_id, db)
    item = await crud_checklist_item.get(db, item_id)
    if not item or item.checklist_id != checklist_id:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Item not found")
    updated = await ChecklistService.update_item(db, item, current_user.id, body)
    await _broadcast_checklist_update(board, task_id)
    return ResponseBase(data=ChecklistItemResponse.model_validate(updated))


@router.delete("/{checklist_id}/items/{item_id}", status_code=204)
async def delete_item(
    task_id: UUID,
    checklist_id: UUID,
    item_id: UUID,
    db: AsyncSession = Depends(get_db),
    board: Board = Depends(check_board_access),
    current_user: User = Depends(get_current_user),
):
    await _get_checklist_or_404(checklist_id, task_id, db)
    item = await crud_checklist_item.get(db, item_id)
    if not item or item.checklist_id != checklist_id:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Item not found")
    await crud_checklist_item.remove(db, id=item_id)
    await _broadcast_checklist_update(board, task_id)


@router.post("/{checklist_id}/items/{item_id}/toggle", response_model=ResponseBase[ChecklistItemResponse])
async def toggle_item(
    task_id: UUID,
    checklist_id: UUID,
    item_id: UUID,
    db: AsyncSession = Depends(get_db),
    board: Board = Depends(check_board_access),
    current_user: User = Depends(get_current_user),
):
    await _get_checklist_or_404(checklist_id, task_id, db)
    item = await crud_checklist_item.get(db, item_id)
    if not item or item.checklist_id != checklist_id:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Item not found")
    toggled = await ChecklistService.toggle_item(db, item, current_user.id)
    await _broadcast_checklist_update(board, task_id)
    return ResponseBase(data=ChecklistItemResponse.model_validate(toggled))


@router.patch("/{checklist_id}/items/{item_id}/reorder", response_model=ResponseBase[ChecklistItemResponse])
async def reorder_item(
    task_id: UUID,
    checklist_id: UUID,
    item_id: UUID,
    body: ChecklistItemReorder,
    db: AsyncSession = Depends(get_db),
    board: Board = Depends(check_board_access),
):
    await _get_checklist_or_404(checklist_id, task_id, db)
    item = await crud_checklist_item.get(db, item_id)
    if not item or item.checklist_id != checklist_id:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Item not found")
    item.position = body.position
    db.add(item)
    await db.flush()
    await db.refresh(item)
    await _broadcast_checklist_update(board, task_id)
    return ResponseBase(data=ChecklistItemResponse.model_validate(item))
```

### Router Registration

**File:** `backend/app/main.py` — add `checklists` to import list and `router_module` loop:
```python
from app.api.v1 import checklists  # add to imports
# add `checklists` to the router_module for loop
```

---

## 5. Service Layer

**File:** `backend/app/services/checklist_service.py`

```python
from datetime import UTC, datetime
from uuid import UUID

from sqlalchemy.ext.asyncio import AsyncSession

from app.crud import crud_activity_log
from app.crud.checklist import crud_checklist
from app.crud.checklist_item import crud_checklist_item
from app.models.checklist import Checklist
from app.models.checklist_item import ChecklistItem
from app.models.task import Task
from app.schemas.checklist import (
    ChecklistCreate,
    ChecklistItemCreate,
    ChecklistItemUpdate,
    ChecklistUpdate,
)


POSITION_GAP = 1024.0


class ChecklistService:
    @staticmethod
    async def create_checklist(
        db: AsyncSession,
        task: Task,
        user_id: UUID,
        body: ChecklistCreate,
    ) -> Checklist:
        max_pos = await crud_checklist.get_max_position(db, task.id)
        position = (max_pos or 0) + POSITION_GAP

        checklist = Checklist(
            task_id=task.id,
            title=body.title,
            position=position,
        )
        db.add(checklist)
        await db.flush()
        await db.refresh(checklist, ["items"])

        await crud_activity_log.log(
            db,
            project_id=task.project_id,
            user_id=user_id,
            action="updated",
            entity_type="task",
            task_id=task.id,
            changes={"checklist": f'added "{body.title}"'},
        )
        return checklist

    @staticmethod
    async def update_checklist(
        db: AsyncSession,
        checklist: Checklist,
        user_id: UUID,
        body: ChecklistUpdate,
    ) -> Checklist:
        if body.title is not None:
            checklist.title = body.title
        db.add(checklist)
        await db.flush()
        await db.refresh(checklist, ["items"])
        return checklist

    @staticmethod
    async def delete_checklist(
        db: AsyncSession,
        checklist: Checklist,
        user_id: UUID,
    ) -> None:
        task_id = checklist.task_id
        title = checklist.title
        await db.delete(checklist)
        await db.flush()

        # Fetch task for project_id (for activity log)
        from app.crud import crud_task
        task = await crud_task.get(db, task_id)
        if task:
            await crud_activity_log.log(
                db,
                project_id=task.project_id,
                user_id=user_id,
                action="updated",
                entity_type="task",
                task_id=task_id,
                changes={"checklist": f'removed "{title}"'},
            )

    @staticmethod
    async def create_item(
        db: AsyncSession,
        checklist: Checklist,
        user_id: UUID,
        body: ChecklistItemCreate,
    ) -> ChecklistItem:
        max_pos = await crud_checklist_item.get_max_position(db, checklist.id)
        position = (max_pos or 0) + POSITION_GAP

        item = ChecklistItem(
            checklist_id=checklist.id,
            title=body.title,
            position=position,
            assignee_id=body.assignee_id,
            due_date=body.due_date,
        )
        db.add(item)
        await db.flush()
        await db.refresh(item, ["assignee"])
        return item

    @staticmethod
    async def update_item(
        db: AsyncSession,
        item: ChecklistItem,
        user_id: UUID,
        body: ChecklistItemUpdate,
    ) -> ChecklistItem:
        update_data = body.model_dump(exclude_unset=True)
        for field, value in update_data.items():
            if field == "is_completed":
                item.is_completed = value
                item.completed_at = datetime.now(UTC) if value else None
            else:
                setattr(item, field, value)
        db.add(item)
        await db.flush()
        await db.refresh(item, ["assignee"])
        return item

    @staticmethod
    async def toggle_item(
        db: AsyncSession,
        item: ChecklistItem,
        user_id: UUID,
    ) -> ChecklistItem:
        item.is_completed = not item.is_completed
        item.completed_at = datetime.now(UTC) if item.is_completed else None
        db.add(item)
        await db.flush()
        await db.refresh(item, ["assignee"])
        return item
```

---

## 6. CRUD Layer

### `backend/app/crud/checklist.py`

```python
from uuid import UUID

from sqlalchemy import select, func
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from app.crud.base import CRUDBase
from app.models.checklist import Checklist
from app.schemas.checklist import ChecklistCreate, ChecklistUpdate


class CRUDChecklist(CRUDBase[Checklist, ChecklistCreate, ChecklistUpdate]):
    async def get_with_items(self, db: AsyncSession, checklist_id: UUID) -> Checklist | None:
        result = await db.execute(
            select(Checklist)
            .where(Checklist.id == checklist_id)
            .options(
                selectinload(Checklist.items).selectinload(
                    __import__("app.models.checklist_item", fromlist=["ChecklistItem"]).ChecklistItem.assignee
                )
            )
        )
        return result.scalar_one_or_none()

    async def get_multi_by_task(self, db: AsyncSession, task_id: UUID) -> list[Checklist]:
        from app.models.checklist_item import ChecklistItem
        result = await db.execute(
            select(Checklist)
            .where(Checklist.task_id == task_id)
            .options(selectinload(Checklist.items).selectinload(ChecklistItem.assignee))
            .order_by(Checklist.position)
        )
        return list(result.scalars().unique().all())

    async def get_max_position(self, db: AsyncSession, task_id: UUID) -> float | None:
        result = await db.execute(
            select(func.max(Checklist.position)).where(Checklist.task_id == task_id)
        )
        return result.scalar_one_or_none()


crud_checklist = CRUDChecklist(Checklist)
```

### `backend/app/crud/checklist_item.py`

```python
from uuid import UUID

from sqlalchemy import select, func
from sqlalchemy.ext.asyncio import AsyncSession

from app.crud.base import CRUDBase
from app.models.checklist_item import ChecklistItem
from app.schemas.checklist import ChecklistItemCreate, ChecklistItemUpdate


class CRUDChecklistItem(CRUDBase[ChecklistItem, ChecklistItemCreate, ChecklistItemUpdate]):
    async def get_max_position(self, db: AsyncSession, checklist_id: UUID) -> float | None:
        result = await db.execute(
            select(func.max(ChecklistItem.position))
            .where(ChecklistItem.checklist_id == checklist_id)
        )
        return result.scalar_one_or_none()

    async def count_by_checklist(self, db: AsyncSession, checklist_id: UUID) -> tuple[int, int]:
        """Returns (total, completed) counts."""
        total = await self.count(db, filters={"checklist_id": checklist_id})
        completed_result = await db.execute(
            select(func.count())
            .select_from(ChecklistItem)
            .where(ChecklistItem.checklist_id == checklist_id, ChecklistItem.is_completed == True)
        )
        completed = completed_result.scalar_one()
        return total, completed


crud_checklist_item = CRUDChecklistItem(ChecklistItem)
```

### CRUD Registration

**File:** `backend/app/crud/__init__.py` — add:
```python
from .checklist import crud_checklist
from .checklist_item import crud_checklist_item
```

Add both to `__all__`.

### Task CRUD Update

**File:** `backend/app/crud/task.py` — add `Checklist` and `ChecklistItem` to `_task_load_options` so checklists are eagerly loaded with tasks:

```python
from app.models.checklist import Checklist
from app.models.checklist_item import ChecklistItem

# Add to _task_load_options tuple:
selectinload(Task.checklists).selectinload(Checklist.items).selectinload(ChecklistItem.assignee),
```

---

## 7. Frontend Types

**File:** `frontend/src/types/task.ts` — add:

```typescript
export interface ChecklistItem {
  id: string
  checklist_id: string
  title: string
  is_completed: boolean
  position: number
  assignee: UserBrief | null
  due_date: string | null
  completed_at: string | null
  created_at: string
  updated_at: string
}

export interface Checklist {
  id: string
  task_id: string
  title: string
  position: number
  items: ChecklistItem[]
  created_at: string
  updated_at: string
}

export interface ChecklistProgress {
  total: number
  completed: number
}

export interface ChecklistItemCreate {
  title: string
  assignee_id?: string
  due_date?: string
}

export interface ChecklistItemUpdate {
  title?: string
  is_completed?: boolean
  assignee_id?: string | null
  due_date?: string | null
}
```

Add to `Task` interface:
```typescript
checklist_progress: ChecklistProgress
```

---

## 8. Frontend Hooks

**File:** `frontend/src/hooks/useChecklists.ts`

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { api } from '@/lib/api-client'
import type { ChecklistItemCreate, ChecklistItemUpdate } from '@/types'

const checklistKey = (projectId: string, boardId: string, taskId: string) =>
  ['checklists', projectId, boardId, taskId] as const

export function useChecklists(projectId: string, boardId: string, taskId: string) {
  return useQuery({
    queryKey: checklistKey(projectId, boardId, taskId),
    queryFn: () => api.listChecklists(projectId, boardId, taskId),
    enabled: !!projectId && !!boardId && !!taskId,
  })
}

export function useCreateChecklist(projectId: string, boardId: string, taskId: string) {
  const qc = useQueryClient()
  return useMutation({
    mutationFn: (data: { title: string }) =>
      api.createChecklist(projectId, boardId, taskId, data),
    onSuccess: () => {
      qc.invalidateQueries({ queryKey: checklistKey(projectId, boardId, taskId) })
      qc.invalidateQueries({ queryKey: ['tasks', projectId, boardId] })
    },
  })
}

export function useUpdateChecklist(projectId: string, boardId: string, taskId: string) {
  const qc = useQueryClient()
  return useMutation({
    mutationFn: ({ checklistId, data }: { checklistId: string; data: { title?: string } }) =>
      api.updateChecklist(projectId, boardId, taskId, checklistId, data),
    onSuccess: () => {
      qc.invalidateQueries({ queryKey: checklistKey(projectId, boardId, taskId) })
    },
  })
}

export function useDeleteChecklist(projectId: string, boardId: string, taskId: string) {
  const qc = useQueryClient()
  return useMutation({
    mutationFn: (checklistId: string) =>
      api.deleteChecklist(projectId, boardId, taskId, checklistId),
    onSuccess: () => {
      qc.invalidateQueries({ queryKey: checklistKey(projectId, boardId, taskId) })
      qc.invalidateQueries({ queryKey: ['tasks', projectId, boardId] })
    },
  })
}

export function useCreateChecklistItem(projectId: string, boardId: string, taskId: string) {
  const qc = useQueryClient()
  return useMutation({
    mutationFn: ({ checklistId, data }: { checklistId: string; data: ChecklistItemCreate }) =>
      api.createChecklistItem(projectId, boardId, taskId, checklistId, data),
    onSuccess: () => {
      qc.invalidateQueries({ queryKey: checklistKey(projectId, boardId, taskId) })
      qc.invalidateQueries({ queryKey: ['tasks', projectId, boardId] })
    },
  })
}

export function useUpdateChecklistItem(projectId: string, boardId: string, taskId: string) {
  const qc = useQueryClient()
  return useMutation({
    mutationFn: ({
      checklistId,
      itemId,
      data,
    }: {
      checklistId: string
      itemId: string
      data: ChecklistItemUpdate
    }) => api.updateChecklistItem(projectId, boardId, taskId, checklistId, itemId, data),
    onSuccess: () => {
      qc.invalidateQueries({ queryKey: checklistKey(projectId, boardId, taskId) })
      qc.invalidateQueries({ queryKey: ['tasks', projectId, boardId] })
    },
  })
}

export function useDeleteChecklistItem(projectId: string, boardId: string, taskId: string) {
  const qc = useQueryClient()
  return useMutation({
    mutationFn: ({ checklistId, itemId }: { checklistId: string; itemId: string }) =>
      api.deleteChecklistItem(projectId, boardId, taskId, checklistId, itemId),
    onSuccess: () => {
      qc.invalidateQueries({ queryKey: checklistKey(projectId, boardId, taskId) })
      qc.invalidateQueries({ queryKey: ['tasks', projectId, boardId] })
    },
  })
}

export function useToggleChecklistItem(projectId: string, boardId: string, taskId: string) {
  const qc = useQueryClient()
  return useMutation({
    mutationFn: ({ checklistId, itemId }: { checklistId: string; itemId: string }) =>
      api.toggleChecklistItem(projectId, boardId, taskId, checklistId, itemId),
    onSettled: () => {
      qc.invalidateQueries({ queryKey: checklistKey(projectId, boardId, taskId) })
      qc.invalidateQueries({ queryKey: ['tasks', projectId, boardId] })
    },
  })
}

export function useReorderChecklistItem(projectId: string, boardId: string, taskId: string) {
  const qc = useQueryClient()
  return useMutation({
    mutationFn: ({
      checklistId,
      itemId,
      position,
    }: {
      checklistId: string
      itemId: string
      position: number
    }) => api.reorderChecklistItem(projectId, boardId, taskId, checklistId, itemId, position),
    onSuccess: () => {
      qc.invalidateQueries({ queryKey: checklistKey(projectId, boardId, taskId) })
    },
  })
}
```

### Cache Invalidation Strategy

- **Toggle/Create/Delete item**: invalidate `['checklists', ...]` AND `['tasks', ...]` (progress count changes)
- **Reorder item/checklist**: invalidate `['checklists', ...]` only (no progress change)
- **Create/Delete checklist**: invalidate both (task response includes aggregate)
- **Update checklist title**: invalidate `['checklists', ...]` only
- **Toggle uses `onSettled`** (not `onSuccess`) to support optimistic UI with rollback

### API Client Methods

**File:** `frontend/src/lib/api-client.ts` — add to `APIClient` class:

```typescript
// Checklists
async listChecklists(projectId: string, boardId: string, taskId: string) {
  return this.request<APIResponse<Checklist[]>>(
    `/projects/${projectId}/boards/${boardId}/tasks/${taskId}/checklists`
  )
}

async createChecklist(projectId: string, boardId: string, taskId: string, data: { title: string }) {
  return this.request<APIResponse<Checklist>>(
    `/projects/${projectId}/boards/${boardId}/tasks/${taskId}/checklists`,
    { method: 'POST', body: JSON.stringify(data) }
  )
}

async updateChecklist(projectId: string, boardId: string, taskId: string, checklistId: string, data: { title?: string }) {
  return this.request<APIResponse<Checklist>>(
    `/projects/${projectId}/boards/${boardId}/tasks/${taskId}/checklists/${checklistId}`,
    { method: 'PATCH', body: JSON.stringify(data) }
  )
}

async deleteChecklist(projectId: string, boardId: string, taskId: string, checklistId: string) {
  return this.request<void>(
    `/projects/${projectId}/boards/${boardId}/tasks/${taskId}/checklists/${checklistId}`,
    { method: 'DELETE' }
  )
}

async createChecklistItem(projectId: string, boardId: string, taskId: string, checklistId: string, data: ChecklistItemCreate) {
  return this.request<APIResponse<ChecklistItem>>(
    `/projects/${projectId}/boards/${boardId}/tasks/${taskId}/checklists/${checklistId}/items`,
    { method: 'POST', body: JSON.stringify(data) }
  )
}

async updateChecklistItem(projectId: string, boardId: string, taskId: string, checklistId: string, itemId: string, data: ChecklistItemUpdate) {
  return this.request<APIResponse<ChecklistItem>>(
    `/projects/${projectId}/boards/${boardId}/tasks/${taskId}/checklists/${checklistId}/items/${itemId}`,
    { method: 'PATCH', body: JSON.stringify(data) }
  )
}

async deleteChecklistItem(projectId: string, boardId: string, taskId: string, checklistId: string, itemId: string) {
  return this.request<void>(
    `/projects/${projectId}/boards/${boardId}/tasks/${taskId}/checklists/${checklistId}/items/${itemId}`,
    { method: 'DELETE' }
  )
}

async toggleChecklistItem(projectId: string, boardId: string, taskId: string, checklistId: string, itemId: string) {
  return this.request<APIResponse<ChecklistItem>>(
    `/projects/${projectId}/boards/${boardId}/tasks/${taskId}/checklists/${checklistId}/items/${itemId}/toggle`,
    { method: 'POST' }
  )
}

async reorderChecklistItem(projectId: string, boardId: string, taskId: string, checklistId: string, itemId: string, position: number) {
  return this.request<APIResponse<ChecklistItem>>(
    `/projects/${projectId}/boards/${boardId}/tasks/${taskId}/checklists/${checklistId}/items/${itemId}/reorder`,
    { method: 'PATCH', body: JSON.stringify({ position }) }
  )
}
```

Add `Checklist`, `ChecklistItem`, `ChecklistItemCreate`, `ChecklistItemUpdate` to the import block at the top of `api-client.ts`.

---

## 9. UI Components

### Component Tree

```
TaskDetailPanel
  ...existing sections...
  <ChecklistSection>                   ← NEW (between Description and Tabs)
    <AddChecklistButton />
    <ChecklistBlock>                   ← one per checklist
      <ChecklistHeader />              ← title, progress bar, collapse toggle, delete
      <DndContext>                      ← dnd-kit for item reorder
        <SortableContext>
          <ChecklistItemRow />         ← checkbox, title, assignee, due date, drag handle
        </SortableContext>
      </DndContext>
      <AddItemInput />                 ← inline input to add new item
    </ChecklistBlock>
  </ChecklistSection>

TaskCard
  ...existing content...
  <ChecklistProgressBar />             ← NEW (thin bar under labels, before footer divider)
```

### `ChecklistSection` Component

**File:** `frontend/src/components/tasks/ChecklistSection.tsx`

**Props:**
```typescript
interface ChecklistSectionProps {
  projectId: string
  boardId: string
  taskId: string
}
```

**Behavior:**
- Fetches checklists via `useChecklists(projectId, boardId, taskId)`
- "Add checklist" button at top right — click reveals inline text input with auto-focus
- On Enter or blur (if non-empty), calls `useCreateChecklist` with title, defaults to "Checklist"
- Renders a `ChecklistBlock` for each checklist, ordered by position
- Wrapped in `motion.div` with `fadeUp` variant matching existing panel sections

### `ChecklistBlock` Component

**Props:**
```typescript
interface ChecklistBlockProps {
  checklist: Checklist
  projectId: string
  boardId: string
  taskId: string
  members: ProjectMember[]
}
```

**Behavior:**
- **Header row**: Inline-editable title (click to edit, blur/Enter to save via `useUpdateChecklist`), progress text "X/Y", collapse/expand toggle (`ChevronDown`), delete button (trash icon, confirm dialog)
- **Progress bar**: Thin horizontal bar below header. Width = `(completed / total) * 100%`. Uses CSS transition for smooth fill animation. Color derived from `var(--accent-solid)` with glow on 100% completion
- **Items list**: Wrapped in dnd-kit `DndContext` + `SortableContext` for drag reorder within this checklist. Vertical list strategy
- **Add item input**: Persistent inline input at bottom of items list. Placeholder "Add an item...". Enter creates item, clears input, keeps focus. Escape blurs

### `ChecklistItemRow` Component

**Props:**
```typescript
interface ChecklistItemRowProps {
  item: ChecklistItem
  checklistId: string
  projectId: string
  boardId: string
  taskId: string
  members: ProjectMember[]
}
```

**Behavior:**
- **Drag handle**: `GripVertical` icon on left, visible on hover
- **Checkbox**: Custom styled checkbox. On click, calls `useToggleChecklistItem`. Completed items get `line-through` + reduced opacity on title text. Checkbox uses spring animation (framer-motion `motion.div` with `scale` keyframe on toggle)
- **Title**: Inline-editable text. Click to edit, blur/Enter to save via `useUpdateChecklistItem`
- **Assignee avatar**: Small avatar if `item.assignee` exists, or a subtle `+` button to assign. Uses a `Popover` with member list (same pattern as `PersonPicker` in TaskDetailPanel but single-select)
- **Due date**: If set, small date badge. Click opens date input popover. Overdue styling matches existing pattern (red text)
- **Delete**: `X` icon on far right, visible on hover

### `ChecklistProgressBar` Component (for TaskCard)

**File:** Add inline to `TaskCard.tsx`

**Behavior:**
- Only renders if `task.checklist_progress.total > 0`
- Thin bar (2px height, rounded) under labels section, before the footer divider
- Background: `var(--border-subtle)`. Fill: `var(--accent-solid)`. Width animated via CSS transition
- On 100% complete: fill color changes to green (`var(--priority-low)`) with subtle glow
- Compact text "X/Y" on right side only if card has space (> 3 items), otherwise bar only

---

## 10. UI Design Spec

### ChecklistSection Container
- Wrapper: `mb-6` matching other sections in TaskDetailPanel
- Section header: Same pattern as Labels/Description sections — icon + uppercase label
- Icon: `ListChecks` from Lucide (or `CheckSquare`)
- Header text: `CHECKLISTS` in `text-xs font-semibold text-[var(--text-tertiary)] uppercase tracking-wider`

### Add Checklist Button
- Located right of section header (same row, `justify-between`)
- Style: `text-[11px] text-[var(--text-tertiary)] hover:text-[var(--accent-solid)]` with `Plus` icon
- When clicked, transforms into an inline `Input` with auto-focus

### ChecklistBlock Card
- Container: `rounded-xl border border-[var(--border-subtle)] bg-[var(--surface)] mb-3 overflow-hidden`
- No padding on container (header and items handle their own padding)

### Checklist Header
- Layout: `flex items-center gap-2 px-4 py-2.5`
- Title: `text-sm font-semibold text-foreground` (click to edit)
- Progress text: `text-[11px] text-[var(--text-tertiary)] font-medium` showing "3/5"
- Collapse toggle: `ChevronDown` icon, 180deg rotation when collapsed via CSS transform + transition
- Delete: `Trash2` icon, `size-3.5`, `text-[var(--text-tertiary)] hover:text-[var(--priority-urgent)]`, visible on hover of header row

### Progress Bar
- Container: `h-[3px] mx-4 mb-2 rounded-full bg-[var(--border-subtle)] overflow-hidden`
- Fill: `h-full rounded-full transition-all duration-500 ease-out`
- Fill color: `bg-[var(--accent-solid)]`
- On 100%: `bg-emerald-500` with `box-shadow: 0 0 8px rgba(16, 185, 129, 0.4)` glow
- On 0 items: no bar rendered

### Checklist Item Row
- Layout: `flex items-center gap-2 px-4 py-1.5 group hover:bg-[var(--elevated)] transition-colors`
- Drag handle: `GripVertical size-3 text-[var(--text-tertiary)] opacity-0 group-hover:opacity-100 transition-opacity cursor-grab`
- Checkbox: `size-4 rounded-md border-2 border-[var(--border-strong)]` — checked state: filled with `var(--accent-solid)`, white checkmark inside, spring scale animation
- Title text: `text-sm text-foreground` — completed: `line-through text-[var(--text-tertiary)] opacity-60`
- Assignee: `size-5` avatar (same style as TaskDetailPanel assignees), on far right
- Due date badge: `text-[10px] px-1.5 py-0.5 rounded-md bg-[var(--surface)]` — overdue: `text-[var(--priority-urgent)] bg-[var(--priority-urgent)]/10`
- Delete icon: `X size-3 text-[var(--text-tertiary)] opacity-0 group-hover:opacity-50 hover:opacity-100 hover:text-[var(--priority-urgent)]`

### Add Item Input
- Layout: `px-4 py-2 border-t border-[var(--border-subtle)]`
- Input: `text-sm bg-transparent border-0 outline-none placeholder:text-[var(--text-tertiary)] w-full` with placeholder "Add an item..."
- Plus icon before input: `Plus size-3.5 text-[var(--text-tertiary)]`

### TaskCard Progress Bar
- Position: After labels, before footer divider (or after description if no labels)
- Container: `mt-2.5 flex items-center gap-2`
- Bar: `flex-1 h-[3px] rounded-full bg-[var(--border-subtle)] overflow-hidden`
- Fill: `h-full rounded-full bg-[var(--accent-solid)] transition-all duration-300`
- Text: `text-[10px] text-[var(--text-tertiary)] font-medium tabular-nums` showing "3/5"
- 100% complete: fill = `bg-emerald-500`, text = `text-emerald-500`

### Animations
- **Checkbox toggle**: `motion.div` with `scale: [1, 1.2, 1]` over 300ms spring on check, `scale: [1, 0.9, 1]` on uncheck
- **New item appear**: `motion.div` with `initial={{ opacity: 0, height: 0 }}` `animate={{ opacity: 1, height: 'auto' }}`
- **Item delete**: `AnimatePresence` exit animation: `exit={{ opacity: 0, x: -20, height: 0 }}`
- **Progress bar fill**: CSS `transition: width 500ms ease-out`
- **Collapse/expand**: `AnimatePresence` with `motion.div` height auto-animate on items container

### Responsive
- On mobile (`< sm`), hide drag handles (items reorderable only on desktop)
- Assignee avatar and due date badge stack below title on very narrow screens (< 400px)

---

## 11. Real-time Sync

### WebSocket Event

**Event type:** `checklist.updated`

**Payload:**
```json
{
  "type": "checklist.updated",
  "project_id": "uuid",
  "board_id": "uuid",
  "data": {
    "task_id": "uuid"
  }
}
```

### Frontend Handler

**File:** `frontend/src/hooks/useWebSocket.ts` — add handler:

```typescript
wsManager.on('checklist.updated', (event: WSEvent) => {
  const taskId = event.data.task_id as string
  // Invalidate checklist query for this task
  queryClient.invalidateQueries({ queryKey: ['checklists', projectId, boardId, taskId] })
  // Invalidate task list to update progress on cards
  queryClient.invalidateQueries({ queryKey: ['tasks', projectId, boardId] })
})
```

**Note:** The WebSocket handler needs access to `queryClient`. Since `useWebSocket` already runs inside the React tree, import `useQueryClient` and use it to invalidate. This is consistent with how `task.created/updated/deleted/moved` events already trigger store updates — but for checklists, a simple query invalidation is cleaner than manual store manipulation since checklists are not part of the board store.

### WebSocket Event Types Update

**File:** `frontend/src/types/websocket.ts` — extend `WSTaskEvent.type`:
```typescript
export interface WSChecklistEvent extends WSEvent {
  type: 'checklist.updated'
  data: { task_id: string }
}
```

---

## 12. Edge Cases

### Concurrent Edits
- Two users toggle same item simultaneously: last-write-wins (server is source of truth). WebSocket invalidation re-fetches fresh state for both clients
- Two users reorder items simultaneously: fractional positions (float midpoint) prevent collisions. Position rebalance not needed for checklists (lower volume than tasks)

### Empty States
- No checklists: Section shows "Add a checklist to track subtasks" with dashed border CTA button
- Checklist with 0 items: Progress bar hidden, just the "Add an item..." input visible
- All items completed: Progress bar turns green with glow, "3/3" text in green

### Permission Checks
- All checklist ops require board access (same as comments/attachments)
- Any board member can create/edit/delete any checklist or item (no ownership restriction, matches task editing pattern)
- API key auth (agents) works same as user auth for checklists

### Max Limits
- Max 10 checklists per task (validated in `ChecklistService.create_checklist`)
- Max 50 items per checklist (validated in `ChecklistService.create_item`)
- Title max lengths enforced by Pydantic schema validators (300 chars for checklist, 500 for item)

### Cascade Deletes
- Deleting a task cascade-deletes all checklists and items (FK `ondelete="CASCADE"`)
- Deleting a checklist cascade-deletes all its items
- Deleting an assignee user sets `assignee_id = NULL` on items (`ondelete="SET NULL"`)

### Optimistic UI for Toggle
- On toggle click, immediately flip the checkbox state in local React state
- If server returns error, revert via `onError` rollback
- Use `onSettled` (not just `onSuccess`) to re-fetch regardless of outcome

---

## 13. File Changes

### New Files (Backend — 6 files)

| File | Purpose |
|------|---------|
| `backend/app/models/checklist.py` | Checklist ORM model |
| `backend/app/models/checklist_item.py` | ChecklistItem ORM model |
| `backend/app/schemas/checklist.py` | Pydantic schemas (Create, Update, Response, Reorder, Progress) |
| `backend/app/crud/checklist.py` | CRUD operations for Checklist |
| `backend/app/crud/checklist_item.py` | CRUD operations for ChecklistItem |
| `backend/app/services/checklist_service.py` | Business logic (create, update, delete, toggle, position) |
| `backend/app/api/v1/checklists.py` | REST route handlers (10 endpoints) |
| `backend/alembic/versions/xxxx_add_checklists.py` | Alembic migration |

### New Files (Frontend — 2 files)

| File | Purpose |
|------|---------|
| `frontend/src/hooks/useChecklists.ts` | TanStack Query hooks (9 hooks) |
| `frontend/src/components/tasks/ChecklistSection.tsx` | ChecklistSection + ChecklistBlock + ChecklistItemRow + AddItemInput |

### Modified Files (Backend — 6 files)

| File | Change |
|------|--------|
| `backend/app/models/__init__.py` | Import and export `Checklist`, `ChecklistItem` |
| `backend/app/models/task.py` | Add `checklists` relationship |
| `backend/app/schemas/__init__.py` | Import and export checklist schemas |
| `backend/app/schemas/task.py` | Add `checklist_progress` field + validator to `TaskResponse` |
| `backend/app/crud/__init__.py` | Import and export `crud_checklist`, `crud_checklist_item` |
| `backend/app/crud/task.py` | Add checklist eager-loading to `_task_load_options` |
| `backend/app/main.py` | Import and register `checklists` router |

### Modified Files (Frontend — 5 files)

| File | Change |
|------|--------|
| `frontend/src/types/task.ts` | Add `Checklist`, `ChecklistItem`, `ChecklistProgress`, `ChecklistItemCreate`, `ChecklistItemUpdate` interfaces; add `checklist_progress` to `Task` |
| `frontend/src/types/websocket.ts` | Add `WSChecklistEvent` type |
| `frontend/src/lib/api-client.ts` | Add 9 checklist API methods + type imports |
| `frontend/src/components/board/TaskDetailPanel.tsx` | Import and render `ChecklistSection` between Description and Tabs |
| `frontend/src/components/board/TaskCard.tsx` | Add `ChecklistProgressBar` inline rendering |
| `frontend/src/hooks/useWebSocket.ts` | Add `checklist.updated` event handler |

### Implementation Order

1. Backend models + migration
2. Backend schemas
3. Backend CRUD
4. Backend service
5. Backend routes + registration
6. Frontend types
7. Frontend API client methods
8. Frontend hooks
9. Frontend `ChecklistSection` component
10. Frontend `TaskCard` progress bar
11. Frontend WebSocket handler
12. Manual testing + edge case verification
